{
  "name": "Gradle-workshop",
  "tagline": "",
  "body": "# Setting up\r\n\r\nWe're going to set up the workshop by installing the buildship plugin and cloning the workshop repository from github. I'm using Eclipse Mars SR2 (4.5.2) and the latest version of buildship.\r\n\r\n## Installing buildship\r\n* Go to *Help* > *Eclipse Marketplace...*\r\n* Search for \"*buildship*\"\r\n* Click the *Install* button\r\n* Continue through the wizard, accepting the license\r\n* Restart Eclipse when prompted\r\n\r\n## Cloning the workshop\r\n* Click the Open perspective button\r\n* Select the *Git* perspective\r\n* Click the button to *Clone a Git Repository*\r\n* Set the URI to *placeholder* and click *Next >*\r\n* Select the *master* branch and click *Next >*\r\n* Choose a directory to store the checked out code\r\n * this should *not* be in your eclipse workspace\r\n\r\n## Importing the project\r\n\r\nUnfortunately, eclipse won't give you the option of importing a repository as a gradle project after cloning it, so we have to do it manually.\r\n\r\n* Go to *File* > *Import* and select *Gradle* > *Gradle Project*\r\n* Click *Next >*\r\n* Set the Project root directory to the directory you used when cloning the git repository and click *Next >*\r\n* This project does not have a gradle wrapper, so set the gradle distribution to *Sepcific Gradle version*\r\n* Set the Java home directory to where your IBM JVM is installed\r\n* Click *Next >*\r\n* Wait for buildship to finish downloading Gradle and reading your build file and click *Finish*\r\n\r\nOn the Gradle Tasks view, open *simple-calculator* > *build* and double-click *build*.\r\nIn the console view, you should now see the build failing\r\n\r\n# Adding dependencies\r\n\r\nOur build does not run because our application requires some dependencies which aren't declared in the build.gradle file.\r\n* The application requires parboiled-java 1.1.7\r\n* The unit tests additionally require JUnit 4.12\r\n\r\nWe're going to fetch our dependencies from [maven central]. If you go to the page of the artifact you want to include,\r\nit will helpfully give you a line to add to your gradle file to add the artifact as a dependency of your main code.\r\n\r\nOpen build.gradle and add the following code:\r\n```\r\nrepositories {\r\n\tmavenCentral()\r\n}\r\n\r\ndependencies {\r\n\tcompile 'org.parboiled:parboiled-java:1.1.7'\r\n\r\n\ttestCompile 'junit:junit:4.12'\r\n}\r\n```\r\n\r\nNote that we use `compile` for dependencies of our application and `testCompile` for dependencies of our unit tests.\r\nGradle calls these groupings of dependencies **configurations**. A list of configurations added by the Java plugin and how they're used can be found [in the user guide].\r\n\r\nNow go to the **Gradle Tasks** view again, open **simple-calculator** > **build** and double-click **build**. This time you should see the build complete successfully.\r\n\r\nBut where's our output? Here again, the user guide will tell us that java artifacts are built in build/lib, but by default this folder is hidden in the project explorer in Eclipse.\r\nClick the down arrow in the Project Explorer view and select **Customize view...** (or **Filters...** in the Package Explorer view), uncheck **Gradle build folder** and click **OK**.\r\nNow our jar should show up under `build/libs`.\r\n\r\n# Packaging an application\r\n\r\nOk, now let's build a user-friendly package for our application...\r\nFortunately, gradle's Application plugin does most of the work for us here including creating .bat and shell scripts to launch java with the correct classpath\r\nto run our app and creating an archive which includes all our library dependencies.\r\n\r\nFrom the [Application plugin page] in the user guide, we see that in addition to applying the plugin, we must also set the `mainClassName` property.\r\n\r\nIn build.gradle, replace the top section of the file with this:\r\n```\r\napply plugin: 'java'\r\napply plugin: 'application'\r\n\r\nmainClassName = 'uk.co.azquelt.simplecalc.Main'\r\n```\r\n\r\nFrom the gradle tasks view, build the project again.\r\n\r\nIn our project, we should now have `build/distributions/gradle-workshop.zip` which contains a zipped up directory with a script to run our application.\r\n\r\nAlthough gradle-workshop is a descriptive name for the project, it's not a great name for the built application so let's change that.\r\nThe [application plugin] notes that it adds some properties which we can find on the [Project API](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N14431).\r\nThis tells us that there is an `applicationName` property which we can set. Similarly, on the [Java Plugin page][Java properties] we find the `archivesBaseName` property which will control the name of our compiled jar.\r\n\r\nSet both of these properties in the gradle.build file:\r\n```\r\napplicationName = 'simple-calc'\r\narchivesBaseName = applicationName\r\n```\r\n\r\nBuild the project again, and we see that everything is now named `simple-calc` instead of `gradle-workshop`\r\n\r\n# Running integration tests\r\n\r\nOur project has some integration tests under `src/integrationTest/java`. You might not have noticed them because\r\nthey're not mentioned in the build.gradle file and don't show up as a Java source folder. Let's fix that and make sure they get run when we do our build.\r\n\r\n## Adding a source set\r\n\r\nFirst, let's tell gradle about the source code. The Java plugin has support for additional [source sets][source sets] and will automatically add new tasks and configurations (remember these from earlier?)\r\nfor each new source set that you add. These are explained further down in the [tasks] and [dependency management] sections of the user guide.\r\n\r\nAdd this section near the top of the build.gradle file. It needs to come before the `dependencies` block.\r\n```\r\nsourceSets {\r\n\tintegrationTest\r\n}\r\n```\r\n\r\nWe also need to add the same JUnit dependency to the integrationTestCompile configuration:\r\n```\r\ndependencies {\r\n\tcompile 'org.parboiled:parboiled-java:1.1.7'\r\n\r\n\ttestCompile 'junit:junit:4.12'\r\n\r\n\tintegrationTestCompile 'junit:junit:4.12'\r\n}\r\n```\r\n\r\nNow right-click on the project > *Gradle* > *Refresh Gradle project* and you should see the new integrationTest source folder appear.\r\n\r\n[image]\r\n\r\n## Running the tests\r\n\r\nHowever, if we run the `build` task again, we don't see the integration tests mentioned at all! This is because although we have some new tasks, they're not in the task graph so they can't be executed by the build task.\r\n\r\nLet's have a look at the task graph for the Java plugin (in green) (from the [user guide][task graph]) along with the new tasks that have been added for our source set.\r\n\r\n[image from dot]\r\n\r\nSo the next question is where should they go?\r\n\r\nWell, the only time we need to build the integration tests is when we're going to run the integration tests so they should be a dependency of the task that runs the tests.\r\nBut wait, we don't have a task that runs the tests yet! We need to create this new task and then we can link all of our tasks into the task graph like this:\r\n\r\n[image from dot]\r\n\r\nSo let's start by adding the new `integrationTest` task:\r\n```\r\ntask integrationTest(type: Test) {\r\n\tdependsOn integrationTestClasses\r\n\tdependsOn installDist\r\n\r\n\ttestClassesDir = sourceSets.integrationTest.output.classesDir\r\n\tclasspath = sourceSets.integrationTest.runtimeClasspath\r\n}\r\n```\r\n\r\nBy referencing the [Test task type DSL documentation][test task type], we can see that we need to set up both the directory of test classes, and the classpath. Fortunately, we can get both of those from the [SourceSet interface][sourceset interface] which we can get through the [sourceSets property][sourceSets property] on the project.\r\n\r\nAs well as having the integration tests, we also need the application which the tests will run. To do this we depend on the `installDist` task from the Application plugin which extracts the distribution archive to `build/install/projectName`.\r\n\r\nLastly, to get our task graph looking the way we want it, we also need to have the `check` task depend on our new `integrationTest` task.\r\n```\r\ncheck.dependsOn integrationTest\r\n```\r\n\r\nThis very short example shows how we can add configuration to a task which has already been created by the plugin. If we wanted to add more configuration options, we could also use the form\r\n```\r\ncheck {\r\n    dependsOn integrationTest\r\n    /* ... */\r\n}\r\n```\r\n\r\nNow run the `build` task again, and you should see it build and run the all the tests.\r\n\r\n[Java properties]: https://docs.gradle.org/current/userguide/java_plugin.html#N1529B\r\n[source sets]: https://docs.gradle.org/current/userguide/java_plugin.html#N14E7A\r\n[task graph]: https://docs.gradle.org/current/userguide/java_plugin.html#N14E92\r\n[sourceset interface]: https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/SourceSet.html\r\n[sourceSets property]: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:sourceSets\r\n[test task type]: https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}